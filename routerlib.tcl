#-----------------------------------------------------------------------------------------------------------------------------proc parser_field_pos {exp in} {if {[regexp $exp $in]==0} {return -1};set bitLens [lrange [split [lindex $in 1] "B"] 1 end]; set vars [lrange $in 2 end];#set pos [lsearch -regexp $vars $exp]for {set i 0;set offset 0} {$i < $pos} {incr i} {set offset [expr $offset + [lindex $bitLens $i]]};return [expr $offset/8]}#puts [parser_field_pos "(?i)ch(ec)?ksum" "24 B8B16B16 Ver Len Checksum"]#-----------------------------------------------------------------------------------------------------------------------------proc receive {int pkt} {eval "binary scan \$pkt [lrange $::Ether_Header_parser 1 end]"if {$::Ether_Header_Type_Len != [Hex2Bin [Char2Hex $cfg::PID_IP]]} { return }if {$::Ether_Header_DMAC == [::mac2Bin $::AllSPFRouters_MAC] || $::Ether_Header_DMAC == [::mac2Bin $::AllDRouters_MAC] } {puts "pktLen=[string length $pkt]"#msg:         from         id   rely_to_id to          subject  bodyset msg [list $::server $int 0          OSPF_server ospf     $pkt]catch {::comm::comm send -async $cfg::port(OSPF_server) msg_comm $msg}return}if { $::Ether_Header_DMAC != [::mac2Bin $cfg::myMac]} { return }IPv4_Fwd pkt}proc send args {set intf [lindex $args 0];set pkt [lindex $args 1 ];puts "pkt=[Hex2Char $pkt]";puts $::handle($intf) $pkt;}proc build_ether_header {dmac smac type_len} {set OutPkt([set t Ether)(1)(DMAC]) [mac2Bin $dmac]set OutPkt([set t Ether)(2)(SMAC]) [mac2Bin $smac]set OutPkt([set t Ether)(3)(Type_Len]) [Hex2Bin [Char2Hex $type_len]]set pattern ""append pattern [lindex $::Ether_Header_parser 1]set varList ""set expr "(?i)ether\\)"set indexes [lsort [lsearch -inline -all -regexp [array name OutPkt] $expr]]foreach index $indexes {append varList "$OutPkt($index) "}set pkt [eval "binary format $pattern $varList"];}proc build_ipv4_header {ver hlen dscp ecn len id flags offset ttl pid chksum sip dip} {set OutPkt([set t IP)(01)(Version]) [Dec2Bin4 $ver]  ;#4set OutPkt([set t IP)(02)(HLen])    [Dec2Bin4 $hlen] ;#5set OutPkt([set t IP)(03)(DSCP])    $dscp			;#110000set OutPkt([set t IP)(04)(ECN])     $ecn				;#00set OutPkt([set t IP)(05)(Len])     [Dec2Bin16 $len]	;#128set OutPkt([set t IP)(06)(ID])      [Dec2Bin16 $id]	;#1set OutPkt([set t IP)(07)(Flags])   $flags			;#000set OutPkt([set t IP)(08)(Offset])  [Hex2Bin [16bitDec2Hex $offset] 13] ;#0set OutPkt([set t IP)(09)(TTL])     [Dec2Bin8 $ttl]	;#1set OutPkt([set t IP)(10)(PID])     [Dec2Bin8 $pid]	;#89set OutPkt([set t IP)(11)(Checksum]) [Hex2Bin $chksum]	;#\x00\x00set OutPkt([set t IP)(12)(SIP])     [IPv42Bin $sip]	;#1.1.1.1set OutPkt([set t IP)(13)(DIP])     [IPv42Bin $dip]	;#2.2.2.2set varList ""set expr "(?i)ip\\)"set indexes [lsort [lsearch -inline -all -regexp [array name OutPkt] $expr]]foreach index $indexes {append varList "$OutPkt($index)"}set pkt [binary format "B[string length $varList]" $varList]}proc update_ip_header_len_chksum {pktIn len} {upvar $pktIn pktset offset [parser_field_pos "(?i)_len" $::IPv4_Header_parser ]; set pkt [string replace $pkt $offset [expr $offset+1] [16bitDec2Hex $len]]set offset [parser_field_pos "(?i)ch(ec)?ksum" $::IPv4_Header_parser ]set pkt [string replace $pkt $offset [expr $offset+1] [16bitDec2Hex [inet_cksum32 $pkt]]]}proc log_msg {time from id rely_to_id to subject body} {global log_dblog_db eval "INSERT INTO msg_log VALUES('$time','$from','$id','$rely_to_id','$to','$subject','')"}proc dump_log {} {global log_dbset db_file "log.db"file delete -force log.dbif {![file exists $db_file]} {log_db backup $db_file} else {log_db eval "ATTACH DATABASE '$db_file' AS backup; \insert into backup.msg_log SELECT * FROM msg_log; \DETACH DATABASE backup;"}return OK}proc inet_cksum32 {data} {        set sum 0;set x {};set c [set b [set a 0]]        set n [binary scan $data I*ccc x a b c]        set a [expr {$a & 0xff}];set b [expr {$b & 0xff}];set c [expr {$c & 0xff}]        if {$n > 1} { set a [expr {$a << 8}] }        if {$n > 3} { set c [expr {$c << 8}] }        lappend x $a $b $c        foreach v $x {set sum [expr {$sum + ($v & 0xffffffff)}]}        return [Inet_cksum_fold_and_complement $sum]		}proc Inet_cksum_fold_and_complement {sum} {        while {$sum > 0xffff} {set sum [expr {($sum & 0xffff) + ($sum >> 16)}]}        return [expr {~$sum & 0xffff}]}proc go {} {        set msg [string repeat [binary format H* 0102030405060708090a0b0c0d0e0f] 99]        set times 1000        puts Tcl:\ [info patch]        puts "Which         Time     Checksum  0"        puts inet_cksum32:\ [format %-10s [lindex [time {inet_cksum32 $msg} $times] 0]]\ ([inet_cksum32 $msg])\ ([format %x [inet_cksum32 [binary format S [inet_cksum32 $msg]]$msg]])}proc 8bitDec2Hex  {in } {binary format c $in} ;# ->\x03  binary scan [8bitInt2Hex 3] H* v1proc 16bitDec2Hex {in {little_endian 0}} {if {$little_endian==0} {binary format S $in} else {binary format s $in}} proc 16bitDec2Hex_L {in {little_endian 1}} {if {$little_endian==0} {binary format S $in} else {binary format s $in}} # ->\x00\x03  binary scan [16bitInt2Hex 3] H* v1proc 32bitDec2Hex {in {little_endian 0}} {if {$little_endian==0} {binary format I $in} else {binary format i $in}}proc 32bitDec2Hex_L {in {little_endian 1}} {if {$little_endian==0} {binary format I $in} else {binary format i $in}}# ->\x00\x03  binary scan [16bitInt2Hex 3] H* v1proc Char2Hex2Dec {in} {Hex2Dec [Char2Hex $in]}proc Char2Hex2Bin {in} {Hex2Bin [Char2Hex $in]}proc Hex2Dec {in} {Bin2Dec [Hex2Bin $in]}proc 8bitHex2Dec  {in } {binary scan $in c var;return [expr { $var & 0xff   }]}proc 16bitHex2Dec {in {little_endian 0}} {if {$little_endian==0} {binary scan $in S var;} else {binary scan $in s var;} ;return [expr { $var & 0xffff   }]}proc 16bitHex2Dec_L {in {little_endian 1}} {if {$little_endian==0} {binary scan $in S var;} else {binary scan $in s var;} ;return [expr { $var & 0xffff   }]}proc 32bitHex2Dec {in {little_endian 0}} {if {$little_endian==0} {binary scan $in I var;} else {binary scan $in i var;} ;return [expr { $var & 0xffffffff   }]}proc 32bitHex2Dec_L {in {little_endian 1}} {if {$little_endian==0} {binary scan $in I var;} else {binary scan $in i var;} ;return [expr { $var & 0xffffffff   }]}proc Bin2Dec_L {in } {Bin2Dec $in 1}#         (-1)**S * 2**(E-Bias) * 1.F\   It is declared as follows:\         float identifier;\         +-------+-------+-------+-------+\         |byte 0 |byte 1 |byte 2 |byte 3 |              SINGLE-PRECISION\         S|   E   |           F          |         FLOATING-POINT NUMBER\         +-------+-------+-------+-------+\         1|<- 8 ->|<-------23 bits------>|\         <------------32 bits------------>proc Bin2Float32 {in} {set S [string index $in 0];set E [expr [Bin2Dec [string range $in 1 8]]-127];set F "1[string range $in 9 31]";return [expr {pow (-1,$S)*[Bin2Dec [string range $F 0 $E]]}]}#Bin2Float32 [Char2Hex2Bin 46fa0000]proc Bin2Float {in} {set bit [string length $in]switch $bit {32 {return [Bin2Float32 $in]}}}proc Bin2Dec {in {little_endian 0}} {set bit [string length $in]if {$bit<=8} {return [8bitBin2Dec [string repeat 0 [expr 8-$bit]]$in ]}if {$bit<=16} {return [16bitBin2Dec [string repeat 0 [expr 16-$bit]]$in $little_endian]}if {$bit<=32} {return [32bitBin2Dec [string repeat 0 [expr 32-$bit]]$in $little_endian]}}proc 8bitBin2Dec  {in} {binary scan [binary format B* $in] c var; return [expr { $var & 0xff   }]}proc 16bitBin2Dec_L {in} {16bitBin2Dec $in 1}proc 16bitBin2Dec {in {little_endian 0}} {if {$little_endian==0} {binary scan [binary format B* $in] S var;} else {binary scan [binary format B* $in] s var;}return [expr { $var & 0xffff }]} proc 32bitBin2Dec_L {in} {32bitBin2Dec $in 1}proc 32bitBin2Dec {in {little_endian 0}} {if {$little_endian==0} {binary scan [binary format B* $in] I var;} else {binary scan [binary format B* $in] i var;};return [expr { $var & 0xffffffff }]}proc Dec2Bin_L {in} {Dec2Bin $in 1}proc Dec2Bin {in bit {little_endian 0}}  {if {$bit<=8} {return [string range [Dec2Bin8 $in] [expr 8-$bit] end]}if {$bit<=16} {return [string range [Dec2Bin16 $in $little_endian] [expr 16-$bit] end]}if {$bit<=32} {return [string range [Dec2Bin32 $in $little_endian] [expr 32-$bit] end]}}proc Dec2Bin4 {in}  {Dec2Bin $in 4}proc Dec2Bin8 {in}  {binary scan [binary format c  $in] B8 var;return $var};#255->11111111proc Dec2Bin16_L {in} {Dec2Bin16 $in 1}proc Dec2Bin16 {in {little_endian 0}} {if {$little_endian==0} {binary scan [binary format S $in] B16 var;} else {binary scan [binary format s $in] B16 var;};return $var};#10->00000001001010000proc Dec2Bin32_L {in} {Dec2Bin32 $in 1}proc Dec2Bin32 {in {little_endian 0}} {if {$little_endian==0} {binary scan [binary format I $in] B32 var;} else {binary scan [binary format i $in] B32 var;};return $var};#10->00000001001010000proc Bin2Hex2Char {in} {Hex2Char [Bin2Hex $in]}proc Bin2Hex {in}  {binary format B* [Bin2Byte $in]};#proc Bin2Byte {in} {set prefix [expr [string length $in]%8]; return [string repeat 0 [expr $prefix>4?(8-$prefix):$prefix]]$in}#Bin2Byte 010 ->00000010proc Hex2Bin {in {bits 0}}  {binary scan $in B* var;if {$bits==0} {return $var;} else {string range $var end-[expr $bits-1] end;}}proc Hex2Char {in} {binary scan $in H* var; return $var}proc Char2Hex {in} {binary format "H*" $in}proc mac2Hex {in} {Char2Hex [regsub -all {[:.]} $in {}]} ;#Hex2Char [mac2Hex 01.e0.00.00.00.02]proc Hex2mac {in} {binary scan $in [string repeat "H2" 6] a1 a2 a3 a4 a5 a6; return "$a1.$a2.$a3.$a4.$a5.$a6"};#Hex2mac [mac2Hex 01.e0.00.00.00.02]proc Bin2mac {in} {Hex2mac [Bin2Hex $in]}proc mac2Bin {in} {Hex2Bin [mac2Hex $in]};#Bin2mac [mac2Bin 01.e0.00.00.00.02]proc HostInPrefix {in} {regexp {(.+)/.+} $in -> host; return $host;} ;#1.0.0.1/16 ->1.0.0.1proc Hex2IPv4 {in} {binary scan $in "c1c1c1c1" a b c d; return "[expr $a & 0xff].[expr $b & 0xff].[expr $c & 0xff].[expr $d & 0xff]" } ;#Hex2IPv4 \x0a\x0a\x0a\x0aproc IPv42Hex {in} {scan $in "%d.%d.%d.%d" a b c d; binary format "c1c1c1c1" $a $b $c $d } proc Bin2IPv4 {in} {return [Hex2IPv4 [Bin2Hex $in]]}proc IPv42Bin {in} {return [Hex2Bin [IPv42Hex $in]]}proc IPv4List2Bin {in} {set var "";foreach ip $in {append var [IPv42Bin $ip] " "};return $var}proc binary_scan {strIn offsetByte parser} {set parser_len [lindex $parser 0];set pattern [lindex $parser 1] ;set varlist [lrange $parser 2 end]set BinStr [Hex2Bin [string range $strIn $offsetByte [expr $offsetByte+$parser_len-1]]]; #puts "binary_scan:pkt=[Bin2Hex2Char $BinStr],offsetByte=$offsetByte,parser=$parser\n"set index 0; set offset 0;set len_list [lrange [split $pattern B] 1 end];set value_list ""foreach var $varlist { set end [expr $offset + [lindex $len_list $index]-1]set $var [string range $BinStr $offset $end]; lappend value_list [string range $BinStr $offset $end]incr index;set offset [incr end 1]}return $value_list}#binary_scan \x45\x45 0 "2 B3B13 ::v1 ::v2"#puts "routerlib:v1=$::v1,v2=$::v2\n"proc lassign args {foreach var [lrange $args 1 end] v [lindex $args 0] {upvar 1 $var my_var; set my_var $v}}#lassign {x {do some} } a b c#puts "$a $b $c" proc apply {fun args} {   set len [llength $fun]   if {($len < 2) || ($len > 3)} {      error "can't interpret \"$fun\" as anonymous function"   }   lassign $fun argList body ns   set name ""; append name :: $ns ::no_one_use   set body0 {      rename [lindex [info level 0] 0] {}   }   proc $name $argList ${body0}$body   set code [catch {uplevel 1 $name $args} res]   return $res}#apply {{x y} {upvar $x x1; set x1 $y}} av 10#puts $av #10proc map {lambda list} {   set result {}   foreach item $list {      lappend result [apply $lambda $item]   }   return $result}#map  {{x y} {upvar $x x1; set x1 $y}} av 10 tr 58#1:a 2:bb 3:ccc 4:ddddproc name_base_parser {parser name_base} {set new_var_list ""foreach var [lrange $parser 2 end] {set var [string range $var 2 end]; set new_var ::$name_base; append new_var $varappend new_var_list $new_var " "}return "[lrange $parser 0 1] $new_var_list"}#name_base_parser "4 B2B4B6 ::OSPF_Router_LSA_v1 ::OSPF_Router_LSA_v2 ::OSPF_Router_LSA_v3" "OSPF_LSU_LSAs_1_"#name_base_parser "4 B2B4B6 ::OSPF_Router_LSA_v1 ::OSPF_Router_LSA_v2 ::OSPF_Router_LSA_v3" ""#4 B2B4 ::OSPF_LSU_LSAs_100_OSPF_Router_LSA_v1 ::OSPF_LSU_LSAs_100_OSPF_Router_LSA_v2#set varName_list "::OSPF_Router_LSA_v1 ::OSPF_Router_LSA_v2"#set values "1 2"#eval "lassign \$values $varName_list"#puts "$::OSPF_Router_LSA_v1 $::OSPF_Router_LSA_v2"proc Len2Mask {in} {if {$in>=32 || $in<0} {return 255.255.255.255} else {set mask [string repeat 1 $in];append mask [string repeat 0 [expr 32-$in]];return [ Bin2IPv4 $mask]}}proc Mask2Len {in} {set mask [IPv42Bin $in];regexp {(1*)} $mask -> count; if {$count==""} {return 0;} else {regexp -all {1} $count}}proc MaskLen2Hex {in} {if {$in>=32} {return \xff\xff\xff\xff}; if {$in<=0} {return \x00\x00\x00\x00};32bitDec2Hex [expr (0xffffffff <<(32-$in)) & 0xffffffff] } ;# 8->0xff000000proc Hex2MaskLen {in} {set mask [Hex2Bin $in]; regexp {0*(1*)} $mask -> count;if {$count==""} {return 0;} else {regexp -all {1} $count}}proc IPv4Prefix {ip len} { if {$len<=0} {return 0.0.0.0}; if {$len>=32} {return $ip};set ipHex   [32bitHex2Dec [IPv42Hex $ip]]; set maskHex "0x[Hex2Char [MaskLen2Hex $len]]"Hex2IPv4 [32bitDec2Hex [expr $ipHex & $maskHex]]}proc ip_equal {ip masklen prefix} {if {[IPv4Prefix $ip $masklen]==$prefix} {return 1}; return 0}proc ip_lower_bits {ip bits} {set ipBin [IPv42Bin $ip];set lower [string range $ipBin end-[expr $bits-1] end];}proc ipToLayer2Multicast {ip} {set low24 "0[ip_lower_bits $ip 23]"; return 01:00:5e:[Bin2Hex2Char [string range $low24 0 7]]:[Bin2Hex2Char [string range $low24 8 15]]:[Bin2Hex2Char [string range $low24 16 23]]}#01:00:5e:00:00:00 - 01:00:5e:7f:ff:ff 23bits of IP#------------------------------------------------------------------------------------------------------------------------------proc lappend_lindex {listIn index sub_element} { set proc lappend_lindexputs "-------------------------------$proc:Begin...list=$listIn,index=$index,sub_element=$sub_element\n"set element [lindex $listIn $index];lappend element $sub_element; set new_list [lreplace $listIn $index $index $element]puts "-------------------------------$proc:End...list=$new_list,index=$index,sub_element=$sub_element\n"return $new_list}proc IPv4_lookup {dipIn fib_matchOut} {global chan1set modName "FIB Lookup"#puts $chan1 "-------------------$modName-----------------------------"upvar $dipIn dipupvar $fib_matchOut fib_match::router_db eval {SELECT * FROM FIB} values {if [ip_equal $dip $values(Mask) $values(IP)] {set fib_match(Nexthop) $values(Nexthop)set fib_match(Interface) $values(Interface)set fib_match(MAC) $values(MAC)return "Match"}}#puts "$dip_mask not match $IP, no route"return "No match"}proc arp_lookup {ip dmacOut} {global chan1set modName "ARP Lookup"#puts $chan1 "-------------------$modName-----------------------------"upvar $dmacOut dmacset dmac [lindex [::router_db eval {SELECT DMAC FROM ARP where IP==$ip}] 0]}proc IfTable_lookup {interface handleOut} {global chan1set modName "IF Lookup"#puts $chan1 "-------------------$modName: $interface-----------------------------"upvar $handleOut handleset handle [lindex [::router_db eval {SELECT Handle FROM Interface where Name==$interface}] 0]}proc IPv4_Fwd {packetIn} {global chan1 pcap1set modName "Forward"upvar $packetIn packetset dip [Hex2IPv4 [string range $packet 30 33]]#----------------- FIB Lookup-----------------------  NextHop, Interface, SMACputs $chan1 "FIB [time {set fib [IPv4_lookup dip fib_match]}]"if {$fib != "Match"} {#puts $chan1 "FIB lookup fail"return}#-------------------------ARP------------- for DMACif { $fib_match(Nexthop) == "Connected" } {set fib_match(Nexthop) $dip}puts $chan1 "ARP [time {arp_lookup $fib_match(Nexthop) dmac}]"if {$dmac == ""} {#puts $chan1 "ARP lookup fail"return}#---------------------------IF-----------------handleputs $chan1 "IF [time {IfTable_lookup $fib_match(Interface) handle}]"if {$handle == ""} {#puts $chan1 "IF lookup fail"return}#-----------------------------Modify Packet----------------------replace SMAC/DMAC CRC?set smac $fib_match(MAC)puts $chan1 "Modify [time {set packet [string replace $packet 0 5  [mac2Hex $dmac] ]set packet [string replace $packet 6 11 [mac2Hex $smac] ]}]"#binary scan $packet H* packetH#puts $chan1 "Send [time { pcap1 send $packet }]"puts $::handle($fib_match(Interface)) $packet}#source "cfg.tcl"package require WPCAPpackage require sqlite3package require udpset sql {create table parser(Protocol text, Message text, Field text,Length text);insert into parser values ('Ether','Header','DMAC','48');insert into parser values ('Ether','Header','SMA','48');insert into parser values ('Ether','Header','Type_Len','16');insert into parser values ('IP','Header','Version','4');insert into parser values ('IP','Header','Hlen','4');insert into parser values ('IP','Header','ToS','8');insert into parser values ('IP','Header','Len','16');insert into parser values ('IP','Header','ID','16');insert into parser values ('IP','Header','Flag','16');insert into parser values ('IP','Header','TTL','8');insert into parser values ('IP','Header','PID','8');insert into parser values ('IP','Header','Checksum','16');insert into parser values ('IP','Header','SIP','32');insert into parser values ('IP','Header','DIP','32');insert into parser values ('OSPF','Header','Version','8');insert into parser values ('OSPF','Header','Type','8');insert into parser values ('OSPF','Header','Len','16');insert into parser values ('OSPF','Header','RID','32');insert into parser values ('OSPF','Header','AID','32');insert into parser values ('OSPF','Header','Checksum','16');insert into parser values ('OSPF','Header','AuthType','16');insert into parser values ('OSPF','Header','AuthData','64');insert into parser values ('OSPF','Hello','Mask','32');insert into parser values ('OSPF','Hello','Interval','16');insert into parser values ('OSPF','Hello','Options','8');insert into parser values ('OSPF','Hello','Pri','8');insert into parser values ('OSPF','Hello','DeadInterval','32');insert into parser values ('OSPF','Hello','DR','32');insert into parser values ('OSPF','Hello','BDR','32');insert into parser values ('OSPF','Hello','Nbrs*','OSPF_Nbr');insert into parser values ('OSPF','Nbr','IP','32');insert into parser values ('OSPF','LLS','Checksum','16');insert into parser values ('OSPF','LLS','Len','16');insert into parser values ('OSPF','LLS_TLV','Type','16');insert into parser values ('OSPF','LLS_TLV','Len','16');}set db_file "router.db"if {[info exists router_db]!=1} {sqlite3 router_db ":memory:";if {[file exists $db_file]} {router_db restore $db_file} else {router_db eval $sql}}sqlite3 log_db ":memory:"log_db eval {create table msg_log(time text, 'from' text, id text, rely_to_id text, 'to' text, subject text, body text)}variable AllSPFRouters 224.0.0.5variable AllDRouters   224.0.0.6variable AllSPFRouters_MAC [ipToLayer2Multicast $AllSPFRouters] ;#01.00.5e.00.00.02variable AllDRouters_MAC [ipToLayer2Multicast $AllDRouters]